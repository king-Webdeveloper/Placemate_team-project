const express = require("express");
const { PrismaClient } = require("@prisma/client");
const jwt = require("jsonwebtoken");

const router = express.Router();
const prisma = new PrismaClient();

/**
 * @swagger
 * /api/planner/user:
 *   get:
 *     summary: ‡∏î‡∏∂‡∏á‡πÅ‡∏ú‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏à‡∏≤‡∏Å Cookie
 *     tags: [Planner]
 *     responses:
 *       200:
 *         description: ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÅ‡∏ú‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
 *       401:
 *         description: Unauthorized - No valid authentication
 *       500:
 *         description: Server error
 */
router.get("/planner/user", async (req, res) => {
    try {
        console.log("‚úÖ GET /planner/user ‡∏ñ‡∏π‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô");
        console.log("Cookies ‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö:", req.cookies);

        const token = req.cookies.auth_token;
        if (!token) {
            console.warn("‚ö† ‡πÑ‡∏°‡πà‡∏°‡∏µ auth_token ‡πÉ‡∏ô Cookie");
            return res.status(401).json({ error: "Unauthorized: No authentication token found" });
        }

        let user_id;
        try {
            const decoded = jwt.verify(token, process.env.JWT_SECRET);
            user_id = decoded.user_id; 
            console.log("‚úÖ Token Decode ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à:", decoded);
        } catch (err) {
            console.error("‚ùå Token ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á:", err);
            return res.status(401).json({ error: "Unauthorized: Invalid or expired token" });
        }

        const plans = await prisma.plan.findMany({
            where: { user_id: parseInt(user_id) },
            include: {
                user: {   
                    select: {
                        user_id: true,
                        username: true,
                        email: true
                    }
                }
            }
        });

        if (!plans || plans.length === 0) {
            console.warn("‚ö† ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÅ‡∏ú‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ:", user_id);
            return res.status(404).json({ error: "No plans found for this user" });
        }

        res.json(plans);
    } catch (error) {
        console.error("Error fetching plans:", error);
        res.status(500).json({ error: "Failed to fetch plans" });
    }
});

/**
 * @swagger
 * /api/planner/add:
 *   post:
 *     summary: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÅ‡∏ú‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà (‡πÉ‡∏ä‡πâ Cookie Authentication)
 *     tags: [Planner]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               title:
 *                 type: string
 *               start_time:
 *                 type: string
 *                 format: date-time
 *               end_time:
 *                 type: string
 *                 format: date-time
 *     responses:
 *       201:
 *         description: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÅ‡∏ú‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
 *       400:
 *         description: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
 *       401:
 *         description: Unauthorized - User not logged in
 *       500:
 *         description: Server error
 */
router.post("/planner/add", async (req, res) => {
    try {
        console.log("‚úÖ POST /planner/add ‡∏ñ‡∏π‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô");
        console.log("Cookies ‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö:", req.cookies);

        const token = req.cookies.auth_token;
        if (!token) {
            console.warn("‚ö† ‡πÑ‡∏°‡πà‡∏°‡∏µ auth_token ‡πÉ‡∏ô Cookie");
            return res.status(401).json({ error: "Unauthorized: No authentication token found" });
        }

        let user_id;
        try {
            const decoded = jwt.verify(token, process.env.JWT_SECRET);
            user_id = decoded.user_id;
            console.log("‚úÖ Token Decode ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à:", decoded);
        } catch (err) {
            console.error("‚ùå Token ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á:", err);
            return res.status(401).json({ error: "Unauthorized: Invalid or expired token" });
        }

        const { title, start_time, end_time } = req.body;
        console.log("üìå ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏à‡∏≤‡∏Å Frontend:", req.body);

        if (!title || !start_time || !end_time) {
            console.warn("‚ö† ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö");
            return res.status(400).json({ error: "title, start_time, and end_time are required" });
        }

        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ start_time ‡πÅ‡∏•‡∏∞ end_time ‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        if (isNaN(Date.parse(start_time)) || isNaN(Date.parse(end_time))) {
            console.warn("‚ö† start_time ‡∏´‡∏£‡∏∑‡∏≠ end_time ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á");
            return res.status(400).json({ error: "Invalid date format" });
        }


        const newPlan = await prisma.plan.create({
            data: {
                user_id: parseInt(user_id),
                title: title,
                start_time: new Date(start_time),
                end_time: new Date(end_time),
                created_at: new Date(),
                updated_at: new Date(),
            }
        });


        console.log("‚úÖ ‡πÅ‡∏ú‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à:", newPlan);
        res.status(201).json(newPlan);
    } catch (error) {
        console.error("‚ùå Error creating plan:", error);
        res.status(500).json({ error: "Failed to create plan" });
    }
});

/**
 * @swagger
 * /api/planner/remove:
 *   delete:
 *     summary: ‡∏•‡∏ö‡πÅ‡∏ú‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á
 *     tags: [Planner]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               plan_id:
 *                 type: integer
 *     responses:
 *       200:
 *         description: ‡∏•‡∏ö‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
 *       400:
 *         description: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
 *       404:
 *         description: ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÅ‡∏ú‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á
 *       403:
 *         description: ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡∏•‡∏ö‡πÅ‡∏ú‡∏ô‡∏ô‡∏µ‡πâ
 *       500:
 *         description: Server error
 */
router.delete("/planner/remove", async (req, res) => {
    try {
        console.log("‚úÖ DELETE /planner/remove ‡∏ñ‡∏π‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô");
        console.log("Cookies ‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö:", req.cookies);


        const token = req.cookies.auth_token;
        if (!token) {
            console.warn("‚ö† ‡πÑ‡∏°‡πà‡∏°‡∏µ auth_token ‡πÉ‡∏ô Cookie");
            return res.status(401).json({ error: "Unauthorized: No authentication token found" });
        }

        let user_id;
        try {
            const decoded = jwt.verify(token, process.env.JWT_SECRET);
            user_id = decoded.user_id;
            console.log("‚úÖ Token Decode ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à:", decoded);
        } catch (err) {
            console.error("‚ùå Token ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á:", err);
            return res.status(401).json({ error: "Unauthorized: Invalid or expired token" });
        }

        const { plan_id } = req.body;
        console.log("üìå ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏•‡∏ö‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà ID:", plan_id);

        if (!plan_id) {
            return res.status(400).json({ error: "plan_id is required" });
        }

        const existingPlan = await prisma.plan.findUnique({
            where: { plan_id: parseInt(plan_id) }
        });

        if (!existingPlan) {
            console.warn("‚ö† ‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö");
            return res.status(404).json({ error: "Plan not found" });
        }

        if (existingPlan.user_id !== parseInt(user_id)) {
            console.warn("‚ö† ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡∏•‡∏ö‡πÅ‡∏ú‡∏ô‡∏ô‡∏µ‡πâ");
            return res.status(403).json({ error: "You do not have permission to delete this plan" });
        }

        await prisma.plan.delete({
            where: { plan_id: parseInt(plan_id) }
        });

        console.log("‚úÖ ‡πÅ‡∏ú‡∏ô‡∏ñ‡∏π‡∏Å‡∏•‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢:", plan_id);
        res.json({ message: "Plan removed successfully" });
    } catch (error) {
        console.error("‚ùå Error removing plan:", error);
        res.status(500).json({ error: "Failed to remove plan" });
    }
});

/**
 * @swagger
 * /api/planner/{planId}/add-place:
 *   post:
 *     summary: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏ô‡πÅ‡∏ú‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á
 *     tags: [Planner]
 *     parameters:
 *       - in: path
 *         name: planId
 *         required: true
 *         schema:
 *           type: integer
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               place_id:
 *                 type: string
 *               start_time:
 *                 type: string
 *                 format: date-time
 *               end_time:
 *                 type: string
 *                 format: date-time
 *     responses:
 *       200:
 *         description: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
 *       400:
 *         description: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
 *       404:
 *         description: ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÅ‡∏ú‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á
 *       500:
 *         description: Server error
 */
router.post("/planner/:planId/add-place", async (req, res) => {
    const { planId } = req.params;
    const { place_id, start_time, end_time } = req.body;
    // const { places } = req.body; // ‡∏£‡∏±‡∏ö‡∏´‡∏•‡∏≤‡∏¢‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô array

    const token = req.cookies.auth_token;
    if (!token) {
        return res.status(401).json({ error: "Unauthorized: No authentication token found" });
    }

    let user_id;
    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        user_id = decoded.user_id;
    } catch (err) {
        return res.status(401).json({ error: "Unauthorized: Invalid or expired token" });
    }

    const plan = await prisma.plan.findUnique({ where: { plan_id: parseInt(planId) } });

    if (!plan) {
        return res.status(404).json({ error: "Plan not found" });
    }

    if (plan.user_id !== parseInt(user_id)) {
        return res.status(403).json({ error: "You do not have permission to add places to this plan" });
    }

    try {
        const newPlaceList = await prisma.place_list.create({
            data: {
                plan_id: parseInt(planId),
                place_id: place_id,
                start_time: new Date(start_time),
                end_time: new Date(end_time),
                created_at: new Date(),
                updated_at: new Date(),
            }
        });

        res.status(201).json(newPlaceList);
    } catch (error) {
        console.error("Error adding place:", error);
        res.status(500).json({ error: "Failed to add place" });
    }
});

/**
 * @swagger
 * /api/planner/{planId}:
 *   get:
 *     summary: ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ú‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á‡∏ï‡∏≤‡∏° planId
 *     tags: [Planner]
 *     parameters:
 *       - in: path
 *         name: planId
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÅ‡∏ú‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á
 *       400:
 *         description: Invalid planId
 *       404:
 *         description: ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÅ‡∏ú‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á
 *       500:
 *         description: Server error
 */
router.get("/planner/:planId", async (req, res) => {
    const { planId } = req.params;

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ planId ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    const parsedPlanId = parseInt(planId);
    if (isNaN(parsedPlanId)) {
        return res.status(400).json({ error: "Invalid planId" });
    }

    try {
        // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÅ‡∏ú‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
        const plan = await prisma.plan.findUnique({
            where: { plan_id: parsedPlanId },
            include: {
                place_list: true,  // ‡∏£‡∏ß‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å place_list
            },
        });

        // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÅ‡∏ú‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á
        if (!plan) {
            return res.status(404).json({ error: "Plan not found" });
        }

        // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ú‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏£‡∏ß‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ
        res.json(plan);
    } catch (error) {
        console.error("Error fetching plan details:", error);
        res.status(500).json({ error: "Failed to fetch plan details" });
    }
});


// ‡∏•‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏≤‡∏Å‡πÅ‡∏ú‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á
router.delete("/planner/:planId/remove-place", async (req, res) => {
    const { planId } = req.params;
    const { place_id } = req.body;

    try {
        const plan = await prisma.plan.findUnique({
            where: { plan_id: parseInt(planId) },
            include: { place_list: true },
        });

        if (!plan) {
            return res.status(404).json({ error: "Plan not found" });
        }

        // ‡∏•‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏à‡∏≤‡∏Å place_list
        const placeList = await prisma.place_list.delete({
            where: { place_list_id: parseInt(place_id) },
        });

        res.status(200).json(placeList);
    } catch (error) {
        console.error("Error removing place from plan:", error);
        res.status(500).json({ error: "Failed to remove place" });
    }
});

/**
 * @swagger
 * /api/places/search:
 *   get:
 *     summary: ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡∏≤‡∏°‡∏ä‡∏∑‡πà‡∏≠
 *     tags: [Places]
 *     parameters:
 *       - in: query
 *         name: query
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏Ñ‡πâ‡∏ô‡∏û‡∏ö
 *       400:
 *         description: ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå query
 *       500:
 *         description: Server error
 */
router.get("/places/search", async (req, res) => {
    try {
        const { query } = req.query;

        if (!query) {
            return res.status(400).json({ error: "Missing query parameter" });
        }

        const places = await prisma.place.findMany({
            where: {
                name: {  // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å place_name ‚Üí name
                    contains: query,
                    mode: "insensitive",
                },
            },
            select: {
                place_id: true,
                name: true,  // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å place_name ‚Üí name
                category: true,
                rating: true,
                lat: true,
                lng: true,
                photo: true,  
            },
        });

        res.json(places);
    } catch (error) {
        console.error("Error searching places:", error);
        res.status(500).json({ error: "Failed to fetch search results" });
    }
});


module.exports = router;
